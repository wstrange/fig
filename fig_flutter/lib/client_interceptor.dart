import 'dart:async';

import 'package:async/async.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:grpc/grpc.dart';

// See https://github.com/grpc/grpc-dart/pull/489#issuecomment-1117204933

typedef HeadersMap = Map<String, String>;

class ResponseFutureImpl<R> extends DelegatingFuture<R>
    implements ResponseFuture<R> {
  Response? pendingCall;

  final Completer<R> _result;
  final _headers = Completer<HeadersMap>();
  final _trailers = Completer<HeadersMap>();

  ResponseFutureImpl._(this._result) : super(_result.future);

  ResponseFutureImpl() : this._(Completer<R>());

  void complete(ResponseFuture<R> other) {
    _result.complete(other);
    _headers.complete(other.headers);
    _trailers.complete(other.trailers);
  }

  @override
  Future<void> cancel() async {
    await pendingCall?.cancel();
  }

  @override
  Future<Map<String, String>> get headers => _headers.future;

  @override
  Future<Map<String, String>> get trailers => _trailers.future;
}


typedef ErrorFunction = Future<void> Function(GrpcError error);

// See also https://grpc-dart-docs.pages.dev/docs/interceptors/client-side-interceptors

class ClientAuthInterceptor implements ClientInterceptor {
  String? authToken; // The firebase auth token
  String? sessionToken; // The session cookie generated by our server.
  ErrorFunction? onError;

  ClientAuthInterceptor({this.onError});
  @override
  ResponseStream<R> interceptStreaming<Q, R>(
      ClientMethod<Q, R> method,
      Stream<Q> requests,
      CallOptions options,
      ClientStreamingInvoker<Q, R> invoker) {
    // TODO: implement interceptStreaming
    throw UnimplementedError();
  }

  @override
  ResponseFuture<R> interceptUnary<Q, R>(ClientMethod<Q, R> method, Q request,
      CallOptions options, ClientUnaryInvoker<Q, R> invoker) {
    final result = ResponseFutureImpl<R>();

    var opt = options;
    // if there is a session token, add it
    if (sessionToken != null) {
      opt = options.mergedWith(CallOptions(metadata: <String, String>{
        'authorization': sessionToken!,
      }));
    }

    Future<void> callWithErrorHandler() async {
      var response = invoker(method, request, opt);
      try {
        await response;
      } catch (e) {
        if (e is GrpcError && e.code == StatusCode.unauthenticated) {
          //print('User unauthenticated. Do something smart');
          // If the user provides a callback, invoke it
          // The callback could trigger a message, or redirect the user to
          // the login page.
          await onError?.call(e);
          // Trigger firebase logout...
          await FirebaseAuth.instance.signOut();
        }
      } finally {
        result.pendingCall = null;
      }
      result.complete(response);
      return;
    }

    callWithErrorHandler();
    return result;
  }
}
